一、功能需求
二、技术选型
三、关键流程
1. 注册与邮箱激活
● 目的：确保用户邮箱真实有效，防止虚假注册。
● 流程：
  a. 用户提交邮箱和密码 → 前端调用 POST /auth/register。
  b. 后端创建用户，状态为 PENDING，并返回成功提示。
  c. 前端引导用户至“邮箱验证”页面，提示用户查收或发送验证邮件。
  d.  用户在该页面点击“发送验证码” → 前端调用 POST /auth/email/send-code。
  e. 后端生成验证码，并通过邮件服务发送。
  f. 用户输入验证码 → 前端调用 POST /auth/email/verify-code。
  g. 后端验证成功 → 更新用户状态为 ACTIVE；失败则提示错误。
2. 登录
● 目的：验证用户身份，颁发访问凭证。
● 流程：
  a. 用户输入邮箱和密码 → 调用 POST /auth/login。
  b. 系统校验：
    ■ 邮箱是否存在
    ■ 邮箱是否已激活
    ■ 账号是否被锁定
    ■ 密码是否正确（加盐哈希比对）
  c. 登录成功 → 返回 access_token（短期有效）和 refresh_token（长期有效）。
  d. 前端保存 token。
3. 刷新 Token
● 目的：避免频繁登录，延长会话时间。
● 流程：
  a. 当 access_token 过期时，前端调用 POST /auth/refresh-token，传入 refresh_token。
  b. 系统校验 refresh_token 是否有效：
    ■ 有效 → 生成新的 access_token 并返回。
    ■ 无效或过期 → 返回错误码，提示重新登录。
4. 退出登录
● 目的：主动结束会话，提升安全性。
● 流程：
  a. 用户点击退出 → 前端调用 POST /auth/logout。
  b. 后端收到请求后，必须执行以下操作：
    ■ 将当前 access_token 加入黑名单（Blacklist）。
    ■ 从 Redis 中删除对应的 refresh_token。
  c. 后端返回成功响应。
  d. 前端清理本地缓存的所有 token。
登录阶段时序图
sequenceDiagram
    participant U as 用户
    participant FE as 前端
    participant BE as 后端
    participant ES as 邮件服务

    %% 注册与激活
    U ->> FE: 提交邮箱+密码
    FE ->> BE: POST /auth/register
    BE -->> FE: 注册成功，请验证邮箱
    U ->> FE: (在验证页面)点击“发送验证码”
    FE ->> BE: POST /auth/email/send-code
    BE ->> ES: 发送激活邮件
    ES -->> U: 邮箱收到验证码
    U ->> FE: 输入验证码
    FE ->> BE: POST /auth/email/verify-code
    BE -->> FE: 返回激活成功

    %% 登录
    U ->> FE: 输入邮箱+密码
    FE ->> BE: POST /auth/login
    BE -->> FE: 返回 access_token + refresh_token
    FE ->> U: 保存 token

    %% 刷新 Token
    FE ->> BE: POST /auth/refresh-token (refresh_token)
    BE -->> FE: 返回新的 access_token

    %% 退出登录
    U ->> FE: 点击退出
    FE ->> BE: POST /auth/logout (access_token)
    FE ->> U: 清理本地 token
    BE -->> FE: 返回 Logout Success


四、接口设计
1. 用户注册
POST /auth/register
● 功能：注册账号
● 逻辑：
  a. 校验邮箱格式 & 密码复杂度
  b. 判断邮箱是否已存在
  c. 创建账号，状态设为 PENDING（待激活）
  d. 触发发送激活邮件（验证码）
  e. 返回提示用户去邮箱验证
● 请求
{ "email": "a@b.com", "password": "Pass#1234" }
● 成功响应
{
  "code": 0,
  "msg": "Registered successfully, please verify your email",
  "data": {}
}
● 错误码
● 1001 邮箱已注册
● 1002 邮箱格式错误
● 1003 密码不符合规则
2. 用户登录
POST /auth/login
● 用途：用户登录
● 逻辑：
  a. 校验邮箱、密码是否匹配
  b. 检查用户状态是否 ACTIVE
  c. 如果成功，生成 access_token 和 refresh_token
  d. 返回 token 给前端
● 请求
{ "email": "a@b.com", "password": "Pass#1234" }
● 成功响应
{
  "code": 0,
  "msg": "Login successful",
  "data": {
    "access_token": "xxx.yyy.zzz",
    "refresh_token": "abcdefg",
    "expires_in": 1800
  }
}
● 错误码
● 2001 邮箱或密码错误
● 2002 邮箱未激活
● 2003 账号被锁定
3.管理员登录
POST /admin/login
逻辑：
1. 输入邮箱 + 密码
2. 查询 admin 表
3. 校验密码（加盐哈希）
4. 登录成功 → 返回 access_token + refresh_token + role（如 "ADMIN"）
返回示例：
{
  "code": 0,
  "msg": "Login successful",
  "data": {
    "access_token": "xxx.yyy.zzz",
    "refresh_token": "abcdefg",
    "expires_in": 1800,
    "type": "ADMIN" 
  }
}
3. 用户登出
POST /auth/logout
● 用途：退出登录
● 逻辑：
  a. 后端从 Header 中解析 access_token。
  b. 将该 access_token 加入 Redis 黑名单，并设置其过期时间为该 Token 剩余的有效期。
  c. 从 access_token 中解析出关联信息（如 jti 或 user_id），找到并删除存储在 Redis 中的 refresh_token。
  d. 返回成功响应，前端接收到后清除本地 token。
● Header
Authorization: Bearer <access_token>
● 成功响应
{
  "code": 0,
  "msg": "Logout Success",
  "data": {}
}
● 错误码
4. 向邮箱发送验证码
POST /auth/email/send-code
● 用途：注册时发送激活码（或重发验证码）
● 逻辑：
  a. 根据邮箱查询用户。
  b. 如果用户不存在，或用户的状态不是 PENDING，则返回统一的成功提示（防止信息泄露），但不发送邮件。
  c. 如果用户存在且状态为 PENDING，则生成新的验证码，存入 Redis 并发送邮件。
  d.  无论何种情况，都必须对同一邮箱的请求进行频率限制（防刷）。
● 请求
{ "email": "a@b.com" }
● 成功响应
{
  "code": 0,
  "msg": "If the email exists, a code has been sent",
  "data": {}
}
● 错误码
● 3001 请求过于频繁
5. 校验邮箱验证码
POST /auth/email/verify-code
● 用途：用户输入验证码完成邮箱激活
● 逻辑：
  a. 校验验证码是否正确 & 未过期
  b. 更新用户状态为 ACTIVE
  c. 删除验证码（防止重复使用）
  d. 返回激活成功
● 请求
{ "email": "a@b.com", "code": "384219" }
● 成功响应
{
  "code": 0,
  "msg": "Email verified successfully",
  "data": { "status": "ACTIVE" }
}
● 错误码
● 3002 验证码错误
● 3003 验证码过期
● 3004 错误次数过多
6. 忘记密码
POST /auth/password/forgot
● 功能：申请发送密码重置验证码
● 逻辑：
  a. 前端传入邮箱
  b. 后端查询是否存在该邮箱（如果不存在也返回成功提示，防止暴露用户信息）
  c. 如果存在，生成重置密码验证码，存入缓存（Redis）
  d. 发送邮件给用户
  e. 返回统一提示 “验证码已发送”	
● 请求
{ "email": "a@b.com" }
● 成功响应
{
  "code": 0,
  "msg": "If the email exists, a reset code has been sent",
  "data": {}
}
● 4004 请求过于频繁（防刷）
● 4005 邮箱未注册
7. 重置密码
POST /auth/password/reset
● 功能：重置密码
● 逻辑：
  a. 校验验证码是否正确 & 未过期
  b. 校验新密码复杂度
  c. 更新用户密码（需加盐哈希存储）
  d. 删除验证码（防止重复使用）
  e. 返回重置成功
● 请求
{ "email": "a@b.com", "code": "129004", "new_password": "NewPass#123" }
● 成功响应
{
  "code": 0,
  "msg": "Password reset successfully",
  "data": {}
}
● 错误码
● 4001 验证码错误
● 4002 验证码过期
● 4003 密码不符合规则
8. 获取个人信息
GET /user/me
● 功能：获取当前用户的个人信息
● 逻辑：
  a. 校验用户身份（token）
  b. 查询数据库返回用户信息
● 成功响应
{
  "code": 0,
  "msg": "Success",
  "data": {
    "id": 1,
    "email": "a@b.com",
    "status": "ACTIVE",
    "created_at": "2025-09-01T12:00:00Z"
  }
}
9. 修改个人信息
PUT /user/me
● 功能：修改个人资料
● 逻辑：
  a. 校验用户身份（token）
  b. 更新用户昵称、头像等资料
  c. 返回修改成功
● Header
Authorization: Bearer <access_token>
● 请求
{ "nickname": "小明", "avatar": "https://xxx.com/img.png" }
● 成功响应
{
  "code": 0,
  "msg": "Profile updated successfully",
  "data": {}
}
10.状态刷新
POST /auth/refresh-token
● 功能：刷新 Access Token
● 逻辑：
  a. 校验 refresh_token 是否有效
  b. 如果有效，生成新的 access_token
  c. 返回新的 token
● 请求
{ "refresh_token": "abcdefg" }
● 成功响应
{
  "code": 0,
  "msg": "Token refreshed successfully",
  "data": {
    "access_token": "xxx.yyy.zzz",
    "expires_in": 1800
  }
}
● 错误码
● 6001 Refresh Token 无效
● 6002 Refresh Token 过期
五、库表设计
用户表
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
  email VARCHAR(255) NOT NULL UNIQUE COMMENT '邮箱，唯一',
  password_hash VARCHAR(255) NOT NULL COMMENT '加盐哈希后的密码',
  role ENUM('USER','ADMIN') NOT NULL DEFAULT 'USER' COMMENT '用户角色',
  status ENUM('PENDING','ACTIVE','LOCKED') NOT NULL DEFAULT 'PENDING' COMMENT '账号状态',
  nickname VARCHAR(50) DEFAULT NULL COMMENT '昵称',
  avatar VARCHAR(255) DEFAULT NULL COMMENT '头像URL',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  last_login_at TIMESTAMP NULL COMMENT '最后登录时间',
  INDEX idx_email (email)
) COMMENT='用户表';

● status：PENDING=未激活、ACTIVE=已激活、LOCKED=账号被锁定。
● password_hash：存储加盐后的哈希密码。
● last_login_at：可用于安全监控或登录记录。
● 管理员账户创建：管理员账户不允许通过公开注册接口创建。必须通过数据库初始化脚本或受保护的内部管理接口进行创建，以防止权限提升漏洞。由于管理员只有二哥一位，所以项目启动时初始化一条数据插入，不单独为管理员设计相关接口
邮箱验证码（注册/重置密码）
● Key：email:register:<email> 或 email:reset:<email>
● Value：验证码 + 生成时间/尝试次数
● TTL：120秒
● 优点：自动过期，不占数据库存储；支持限流和防刷
ccess Token / Refresh Token
● Access Token
  ○ 类型：JWT，自包含
  ○ 存储：不存储 Redis
  ○ 验证方式：直接解密并校验
  ○ 用途：携带用户/管理员身份，用于后端权限判断
  ○ Payload 示例：payload 中存储 type（USER / ADMIN）用于后端权限判断
{
  "jti": "a-unique-random-string-12345",
  "sub": <id>,           // 用户ID或管理员ID，用于唯一标识登录主体
  "email": "...",        // 登录账户的邮箱
  "type": "USER|ADMIN",  // 用户类型：普通用户为 USER，管理员/专家为 ADMIN
  "iat": <timestamp>,    // Token 签发时间（Issued At），UNIX 时间戳
  "exp": <timestamp>     // Token 过期时间（Expiration），UNIX 时间戳，到期后需要刷新或重新登录
}

● Refresh Token (存储在 Redis 中)：
  ○ 存储类型：哈希 (Hash)
  ○ Key 格式：refresh_token:user:<user_id>
  ○ Value (Hash Fields):
    ■ token: "actual_refresh_token_string"   // Refresh Token 的值
    ■ jti: "a-unique-random-string-12345"  // 与 Access Token 关联的 JWT ID
    ■ expiresAt: ""               // Refresh Token 的过期时间戳   
  ○ TTL：整个 Key 的过期时间，例如 7 天。   
  ○ 用途：当 access token 过期时，用于刷新生成新的 access token。  
  ○ 登出逻辑：       
    ■ 1. 将 access_token 加入黑名单。       
    ■ 2. 从 access_token 中解析出 user_id。       
    ■ 3. 根据 user_id 从 Redis 中删除对应的 Refresh Token 记录 (Key: refresh_token:user:<user_id>)。
● access token 黑名单（登出时加入）
  ○ Key：blacklist:access_token:<token> → TTL = token 剩余有效期


